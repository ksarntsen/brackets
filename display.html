<!-- display.html -->
<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Turnering – Display</title>
  <style>
    body{
      margin:0;
      font-family: Arial, sans-serif;
      background:#0b0b0d;
      color:#f4f4f6;
      overflow:hidden;
    }
    .wrap{
      max-width:2000px;
      margin:0 auto;
      padding:18px 18px 18px 18px;
    }
    .head{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:16px;
      margin-bottom:10px;
    }
    .title{
      font-size:44px;
      font-weight:900;
      line-height:1.05;
      margin:0;
      letter-spacing:.2px;
    }
    .updated{
      font-size:18px;
      color:rgba(244,244,246,.68);
      font-weight:800;
      white-space:nowrap;
    }

    /* Stage: absolute layout so alignment is computed from actual centers */
    .stage{
      position:relative;
      width:100%;
      border-radius:16px;
      background:rgba(255,255,255,.02);
      border:2px solid rgba(214,31,38,.18);
      overflow:hidden;
    }

    .col{
      position:absolute;
      top:0;
      bottom:0;
      width:310px; /* includes slot width + breathing room */
    }

    .match{
      position:absolute;
      left:0;
      width:310px;
      overflow:visible;
    }

    .when{
      position:absolute;
      top:-18px;
      left:6px;
      font-size:14px;
      font-weight:800;
      color:rgba(244,244,246,.70);
      white-space:nowrap;
      max-width:298px;
      overflow:hidden;
      text-overflow:ellipsis;
      pointer-events:none;
    }

    .slot{
      position:absolute;
      left:0;
      width:290px;
      height:58px;              /* fixed for predictable centering */
      padding:0 12px;
      border-radius:16px;
      background:#121216;
      border:3px solid rgba(214,31,38,.35);
      font-size:26px;
      font-weight:900;
      line-height:1;
      display:flex;
      align-items:center;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      box-shadow:0 16px 40px rgba(0,0,0,.45);
      color:#f4f4f6;
    }
    .slot.empty{
      opacity:.55;
      font-weight:800;
    }
    .slot.winPick{
      border-color:rgba(214,31,38,.95);
      box-shadow:0 0 0 5px rgba(214,31,38,.18) inset, 0 16px 40px rgba(0,0,0,.45);
      background:#0b0b0d;
    }

    .champ{
      position:absolute;
      width:330px;
      height:78px;
      font-size:34px;
      border-width:4px;
    }

    @keyframes moveIn {
      0%   { transform: translateX(-28px); opacity:0; }
      100% { transform: translateX(0); opacity:1; }
    }
    .moveIn{
      animation: moveIn 450ms ease-out both;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="head">
      <div class="title">Turnering</div>
      <div class="updated" id="updated">—</div>
    </div>

    <div id="stage" class="stage"></div>
  </div>

  <script>
    (function(){
      var API_GET = "/.netlify/functions/get-bracket";

      var elStage = document.getElementById("stage");
      var elUpdated = document.getElementById("updated");

      var lastUpdated = null;
      var lastState = null;

      /* Layout constants */
      var SLOT_H = 58;
      var INNER_GAP = 10; /* gap between the two players inside a match */
      var MATCH_H = (SLOT_H * 2) + INNER_GAP;

      var COL_W = 310;     /* column box width */
      var COL_GAP = 90;    /* horizontal spacing between columns */

      function sTrim(s){
        return (s || "").replace(/^\s+|\s+$/g, "");
      }

      function xhrGet(url, cb){
        var x = new XMLHttpRequest();
        x.onreadystatechange = function(){
          if (x.readyState !== 4) return;
          var ok = (x.status >= 200 && x.status < 300);
          var res = null;
          try { res = JSON.parse(x.responseText || "{}"); } catch(e){ res = {}; }
          cb(ok, res);
        };
        x.open("GET", url, true);
        x.send(null);
      }

      function blankState(){
        var i, p = [];
        for (i=0;i<16;i++) p.push("");
        return {
          players: p,
          winners: {
            r16: [null,null,null,null,null,null,null,null],
            qf:  [null,null,null,null],
            sf:  [null,null],
            f:   [null]
          },
          times: {
            r16: ["","","","","","","",""],
            qf:  ["","","",""],
            sf:  ["",""],
            f:   [""]
          },
          updated_at: null
        };
      }

      function safeState(raw){
        var st = blankState();
        if (!raw) return st;

        if (raw.players && raw.players.length === 16) st.players = raw.players;

        if (raw.winners) {
          if (raw.winners.r16 && raw.winners.r16.length === 8) st.winners.r16 = raw.winners.r16;
          if (raw.winners.qf  && raw.winners.qf.length  === 4) st.winners.qf  = raw.winners.qf;
          if (raw.winners.sf  && raw.winners.sf.length  === 2) st.winners.sf  = raw.winners.sf;
          if (raw.winners.f   && raw.winners.f.length   === 1) st.winners.f   = raw.winners.f;
        }

        if (raw.times) {
          if (raw.times.r16 && raw.times.r16.length === 8) st.times.r16 = raw.times.r16;
          if (raw.times.qf  && raw.times.qf.length  === 4) st.times.qf  = raw.times.qf;
          if (raw.times.sf  && raw.times.sf.length  === 2) st.times.sf  = raw.times.sf;
          if (raw.times.f   && raw.times.f.length   === 1) st.times.f   = raw.times.f;
        }

        st.updated_at = raw.updated_at || null;
        return st;
      }

      function computeBracket(st){
        var out = {
          r16: { a:[], b:[], wn:[] },
          qf:  { a:[], b:[], wn:[] },
          sf:  { a:[], b:[], wn:[] },
          f:   { a:[], b:[], wn:[] },
          champ: ""
        };

        var i, a, b, w;

        for (i=0;i<8;i++){
          a = sTrim(st.players[i*2] || "");
          b = sTrim(st.players[i*2+1] || "");
          out.r16.a[i]=a; out.r16.b[i]=b;
          w = st.winners.r16[i];
          out.r16.wn[i] = (w===0) ? a : ((w===1) ? b : "");
        }

        for (i=0;i<4;i++){
          a = out.r16.wn[i*2] || "";
          b = out.r16.wn[i*2+1] || "";
          out.qf.a[i]=a; out.qf.b[i]=b;
          w = st.winners.qf[i];
          out.qf.wn[i] = (w===0) ? a : ((w===1) ? b : "");
        }

        for (i=0;i<2;i++){
          a = out.qf.wn[i*2] || "";
          b = out.qf.wn[i*2+1] || "";
          out.sf.a[i]=a; out.sf.b[i]=b;
          w = st.winners.sf[i];
          out.sf.wn[i] = (w===0) ? a : ((w===1) ? b : "");
        }

        a = out.sf.wn[0] || "";
        b = out.sf.wn[1] || "";
        out.f.a[0]=a; out.f.b[0]=b;
        w = st.winners.f[0];
        out.f.wn[0] = (w===0) ? a : ((w===1) ? b : "");

        out.champ = out.f.wn[0] || "";
        return out;
      }

      function topmostDecidedRound(st){
        if (st.winners.f[0] !== null) return "f";
        if (st.winners.sf[0] !== null || st.winners.sf[1] !== null) return "sf";
        if (st.winners.qf[0] !== null || st.winners.qf[1] !== null || st.winners.qf[2] !== null || st.winners.qf[3] !== null) return "qf";
        if (st.winners.r16[0] !== null || st.winners.r16[1] !== null || st.winners.r16[2] !== null || st.winners.r16[3] !== null ||
            st.winners.r16[4] !== null || st.winners.r16[5] !== null || st.winners.r16[6] !== null || st.winners.r16[7] !== null) return "r16";
        return null;
      }

      function buildAnimTargets(st, br){
        var top = topmostDecidedRound(st);
        var targets = { qf:{}, sf:{}, f:{}, win:{} };
        var i, m, side;

        if (top === "r16") {
          for (i=0;i<8;i++){
            if (st.winners.r16[i] === null) continue;
            if (!br.r16.a[i] || !br.r16.b[i]) continue;
            m = Math.floor(i/2);
            side = (i % 2);
            targets.qf[m + "-" + side] = 1;
          }
        } else if (top === "qf") {
          for (i=0;i<4;i++){
            if (st.winners.qf[i] === null) continue;
            if (!br.qf.a[i] || !br.qf.b[i]) continue;
            m = Math.floor(i/2);
            side = (i % 2);
            targets.sf[m + "-" + side] = 1;
          }
        } else if (top === "sf") {
          for (i=0;i<2;i++){
            if (st.winners.sf[i] === null) continue;
            if (!br.sf.a[i] || !br.sf.b[i]) continue;
            side = (i % 2);
            targets.f["0-" + side] = 1;
          }
        } else if (top === "f") {
          if (st.winners.f[0] !== null && br.f.a[0] && br.f.b[0]) targets.win["champ"] = 1;
        }
        return targets;
      }

      function esc(s){
        s = s || "";
        return s
          .replace(/&/g,"&amp;")
          .replace(/</g,"&lt;")
          .replace(/>/g,"&gt;")
          .replace(/"/g,"&quot;")
          .replace(/'/g,"&#039;");
      }

      function mkWhen(text){
        var t = sTrim(text || "");
        if (!t) return null;
        var d = document.createElement("div");
        d.className = "when";
        d.innerHTML = esc(t);
        return d;
      }

      function mkSlot(text, isWinner, moveIn){
        var d = document.createElement("div");
        d.className = "slot" + (isWinner ? " winPick" : "") + (moveIn ? " moveIn" : "");
        if (!text) d.className += " empty";
        d.innerHTML = esc(text || "—");
        return d;
      }

      function mkMatch(a, b, winnerSide, moveA, moveB, whenText){
        var m = document.createElement("div");
        m.className = "match";

        var w = mkWhen(whenText);
        if (w) m.appendChild(w);

        var sA = mkSlot(a, (winnerSide===0 && a), moveA);
        var sB = mkSlot(b, (winnerSide===1 && b), moveB);

        sA.style.top = "0px";
        sB.style.top = (SLOT_H + INNER_GAP) + "px";

        m.appendChild(sA);
        m.appendChild(sB);

        return m;
      }

      function computeStageHeight(){
        /* Fill the viewport under the header, but keep a floor. */
        var wrap = document.getElementsByClassName("wrap")[0];
        var head = document.getElementsByClassName("head")[0];

        var h = window.innerHeight || 900;
        var used = 0;

        if (wrap && wrap.offsetTop) used += wrap.offsetTop;
        if (head && head.offsetHeight) used += head.offsetHeight;
        used += 26; /* padding/margins */

        var stageH = h - used;
        if (stageH < 520) stageH = 520;
        return stageH;
      }

      function layoutRoundTops(stageH){
        /* Place r16 evenly. Later rounds are centered from previous centers. */
        var r16Top = [];
        var r16Center = [];
        var qfTop = [];
        var qfCenter = [];
        var sfTop = [];
        var sfCenter = [];
        var fTop = [];
        var fCenter = [];

        var i;

        var baseSpacing = (stageH - (8 * MATCH_H)) / 7;
        if (baseSpacing < 6) baseSpacing = 6;

        /* If the stage is too small even with minimal spacing, allow overlap-free squeeze by reducing spacing. */
        if ((8 * MATCH_H) + (7 * baseSpacing) > stageH) {
          baseSpacing = Math.max(0, (stageH - (8 * MATCH_H)) / 7);
        }
        if (baseSpacing < 0) baseSpacing = 0;

        for (i=0;i<8;i++){
          r16Top[i] = i * (MATCH_H + baseSpacing);
          r16Center[i] = r16Top[i] + (MATCH_H / 2);
        }

        for (i=0;i<4;i++){
          qfCenter[i] = (r16Center[i*2] + r16Center[i*2+1]) / 2;
          qfTop[i] = qfCenter[i] - (MATCH_H / 2);
        }

        for (i=0;i<2;i++){
          sfCenter[i] = (qfCenter[i*2] + qfCenter[i*2+1]) / 2;
          sfTop[i] = sfCenter[i] - (MATCH_H / 2);
        }

        fCenter[0] = (sfCenter[0] + sfCenter[1]) / 2;
        fTop[0] = fCenter[0] - (MATCH_H / 2);

        return {
          r16Top: r16Top,
          qfTop: qfTop,
          sfTop: sfTop,
          fTop: fTop,
          fCenter: fCenter
        };
      }

      function render(st){
        var br = computeBracket(st);
        var anim = buildAnimTargets(st, br);

        /* Stage sizing */
        var stageH = computeStageHeight();
        elStage.style.height = stageH + "px";

        /* Build columns */
        elStage.innerHTML = "";

        var colR16 = document.createElement("div");
        colR16.className = "col";
        colR16.style.left = "0px";

        var colQF = document.createElement("div");
        colQF.className = "col";
        colQF.style.left = (COL_W + COL_GAP) + "px";

        var colSF = document.createElement("div");
        colSF.className = "col";
        colSF.style.left = (2*(COL_W + COL_GAP)) + "px";

        var colF = document.createElement("div");
        colF.className = "col";
        colF.style.left = (3*(COL_W + COL_GAP)) + "px";

        var colW = document.createElement("div");
        colW.className = "col";
        colW.style.left = (4*(COL_W + COL_GAP)) + "px";
        colW.style.width = "360px";

        elStage.appendChild(colR16);
        elStage.appendChild(colQF);
        elStage.appendChild(colSF);
        elStage.appendChild(colF);
        elStage.appendChild(colW);

        /* Create matches */
        var r16Els = [];
        var qfEls = [];
        var sfEls = [];
        var fEls = [];

        var i;

        for (i=0;i<8;i++){
          var m16 = mkMatch(
            br.r16.a[i], br.r16.b[i], st.winners.r16[i],
            false, false,
            (st.times && st.times.r16) ? st.times.r16[i] : ""
          );
          r16Els.push(m16);
          colR16.appendChild(m16);
        }

        for (i=0;i<4;i++){
          var mq = mkMatch(
            br.qf.a[i], br.qf.b[i], st.winners.qf[i],
            !!anim.qf[i+"-0"], !!anim.qf[i+"-1"],
            (st.times && st.times.qf) ? st.times.qf[i] : ""
          );
          qfEls.push(mq);
          colQF.appendChild(mq);
        }

        for (i=0;i<2;i++){
          var ms = mkMatch(
            br.sf.a[i], br.sf.b[i], st.winners.sf[i],
            !!anim.sf[i+"-0"], !!anim.sf[i+"-1"],
            (st.times && st.times.sf) ? st.times.sf[i] : ""
          );
          sfEls.push(ms);
          colSF.appendChild(ms);
        }

        var mf = mkMatch(
          br.f.a[0], br.f.b[0], st.winners.f[0],
          !!anim.f["0-0"], !!anim.f["0-1"],
          (st.times && st.times.f) ? st.times.f[0] : ""
        );
        fEls.push(mf);
        colF.appendChild(mf);

        /* Champion */
        var champ = document.createElement("div");
        champ.className = "slot champ" + (br.champ ? " winPick" : "") + (!!anim.win["champ"] ? " moveIn" : "");
        if (!br.champ) champ.className += " empty";
        champ.innerHTML = esc(br.champ || "—");
        colW.appendChild(champ);

        /* Apply computed vertical positions */
        var L = layoutRoundTops(stageH);

        for (i=0;i<8;i++){
          r16Els[i].style.top = L.r16Top[i] + "px";
          r16Els[i].style.height = MATCH_H + "px";
        }
        for (i=0;i<4;i++){
          qfEls[i].style.top = L.qfTop[i] + "px";
          qfEls[i].style.height = MATCH_H + "px";
        }
        for (i=0;i<2;i++){
          sfEls[i].style.top = L.sfTop[i] + "px";
          sfEls[i].style.height = MATCH_H + "px";
        }
        fEls[0].style.top = L.fTop[0] + "px";
        fEls[0].style.height = MATCH_H + "px";

        /* Champion centered on final match center */
        var champH = 78;
        champ.style.top = (L.fCenter[0] - (champH / 2)) + "px";
        champ.style.left = "0px";

        elUpdated.innerHTML = st.updated_at ? ("Sist oppdatert: " + st.updated_at) : "—";
      }

      function tick(){
        xhrGet(API_GET, function(ok, res){
          if (!ok || !res || !res.ok) return;
          var st = safeState(res.state);
          if (st.updated_at && st.updated_at === lastUpdated) return;
          lastUpdated = st.updated_at || null;
          lastState = st;
          render(st);
        });
      }

      function onResize(){
        if (!lastState) return;
        render(lastState);
      }

      tick();
      setInterval(tick, 1500);

      if (window.addEventListener) window.addEventListener("resize", onResize, false);
      else if (window.attachEvent) window.attachEvent("onresize", onResize);
    })();
  </script>
</body>
</html>
